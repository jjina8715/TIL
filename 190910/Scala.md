# Scala

### 개요

- 다중패러다임 언어로, 객체지향 언어의 특성과 함수형 언어의 특성을 함께 가진 언어.
- JVM 상에서 구동, Java와 상호 호환이 가능. .NET을 위한 지원도 제공

### 특징

- 쉬운 언어 확장과 DSL
  - 이름을 Scalable Launguage에서 따온 만큼 언어 확장이 쉽고 도메인 특화 언어(DSL)를 만들 수 있다. 
  - 연산자
    - 식별자명(+, *, ...)을 식별자에 부착 가능
  - 암묵
    - 암묵적으로 어떤 객체를다른 타입으로 변환 가능
    - 암묵적으로 메소드 인자에 쓰일 값을 받을 수 있다.
  - call-by-name evaluation
    - 인자로 코드 블록을 지정 가능
      - 인자 없는 익명 함수에서 인자를 받는 부분을 생략
- 트레이트(trait)
  - 다중 상속 가능. 자바의 인터페이스와 비슷, 믹스인할 수 있는 모듈
  - 인터페이스와 달리 구체적인 구현, 믹스인 가능
  - 케이크 패턴
    - 트레이드를 모듈로 써서 with으로 트레이트를 쭉 쌓는 방식
- 소스가 짧다, 자바에 비해
  - 생성자, 상속
    - 클래스 명 옆의 인자 목록은 기본 클래스 생성자의 인자 목록
    - 슈퍼클래스명 옆의 인자 목록은 호출할 슈퍼 클래스의 생성자에 해당하는 인자 목록
    - 생성자를 오버로딩하고 싶다면 보조생성자를 추가로 생성 가능
    - 보조 생성자의 이름은 this
    - 클래스 본문 전체가 기본 생성자의 본문이 된다는 구성
  - getter, setter를 필드에 따라 내부적으로 자동 생성
    - 호출 : 객체.필드, 객체.필드 = 값
    - 명시적으로 오버라이드 가능
    - 자바빈즈 스타일이 아니기에 자바에서 쉽게 호출 → @BeanProperty
  - sington, 싱글톤
    - object 키워드 사용
    - 스칼라에는 static에 대응되는 키워드가 없다
  - 변수의 타입, 함수의 반환값 타입 등을 컴파일러가 추론
    - 함수 반환값 추론은 사실 거의 쓰이지 않는다.
      - 재귀에선 불가능, public 함수에서는 타입 명시가 관행
  - apply
    - 해당 객체 뒤에 하나 이상의 값을 ()로 둘러싸서 호출시 그 객체의 apply() 메소드를 자동 호출
    - 메소드를 호출하듯 객체 인스턴스를 호출 가능
  - 익명 함수 ex) (a, b) -> a+b
  - {} : 같은 패키지에서 여러개의 클래스를 선택적으로 호출 가능
  - _ : 패키지나 클래스에 속한 모든 이름들을 불러 올 경우에 사용
    - 객체의 모든 값을 불러 올때 사용(print 등에서)
- 패턴 매칭
  - 자바의 switch-case문과 비슷한 기능을 하지만 fall-through가 없다는 차이점이 있다. 
  - 가드와 unapply 메소드와 연계되어 switch문보다 복잡하게 쓰인다.
  - unapply
    - 괄호 안에 목록을 집어 넣으면 그 안에 값을 집어 넣는다. 
    - destructuring을 손쉽게 할 수 있다.
    - 단독으로 쓰일 수도 있지만, 보통은 패턴 매칭에서  구조를 분해하는 데 쓰인다.
- 함수형 프로그래밍 언어
  - 함수는 값
    - 함수형 언어의 기본 특징
    - 함수도 일반적으로 '데이터'라고 생각하는 타입의 값들과 동일한 취급
    - 스칼라에서 모든 값은 객체이므로 함수도 객체
      - 메소드는 객체가 아니다
      - 스칼라에서 메소드와 함수는 다른 것
  - 불변성
    - 변수 선언의 기본 방식 : `val`
      - `val`로 선언된 변수는 그 변수가 더이상 유효하지 않게 될 때까지 그 값이 고정
      - 다만 다른 객체를 가리킬 수는 없지만, 가리키고 있는 객체의 상태가 바뀌는 것은 허용
      - 이를 위해 스칼라의 내장 콜렉션은 mutable과 immutable으로 나뉘어져 있고, 불변 콜렉션을 리턴하는 방식을 사용
    - 대입이 가능한 변수는 `var`로 선언. 권장하지 않는 선언 방식
  - for comprehesion
    - `for - yield`문은 Haskell의 `do`와 같은 기능
    - 루프와는 전혀 다른 성질
    - 모나드를 위한 문법
    - 중첩된 flatMap과 map, 그리고 filter(withFilter) 메소드 호출을 깔끔하게 해주는 역할
  - 타입클래스
    - 함수형 언어에서 사용되는 별도의 다형성 개념
      - Type variable이라는 개념을 넣어 타입 자체를 input으로 받아서 새로운 타입 자체를 output으로 내놓는 함수처럼 사용하는 것
      - Type의 모임이라 보면 간단
    - 스칼라는 타입클래스를 통한 다형성을 자연스럽게 지원하는 몇 안 되는 정적 타입 언어 중 하나
    - 서브 타이핑과 타입클래스가 동시에 자연스럽게 지원되는 언어
    - 타입클래스는 하나의 패턴으로서 다른 언어의 기능들을 활용해서 지원되는 것이고, 언어 차원의 키워드가 비제공
  - 한계
    - JVM이 TCO를 미지원하기 때문에 많은 경우에 트램폴린을 통해 안정성을 확보하지만, 코드가 복잡해지고, 힙을 사용하는 이상 캐시미스가 필연적, 성능이 하락
    - 서브타이핑 지원으로 인해 전역 타입추론이 불가능, 지역 타입추론만이 가능
    - 타입클래스 인코딩에 대한 언어 자체적인 내장 기능이 없다
    - 암묵적인 요소를 많이 사용하면 컴파일 시간이 증가
    - Haskell보다 타수가 많다
    - Haskell 등이 지원하는 몇몇 고급 기능 비지원
- 자바와의 상호 호환
  - 스칼라에서 별다른 절차 없이 자바 코드를 쓸 수 있다. 반대는 불가
  - 자바 라이브러리는 sbt에서 불러올 수 있다
  - XML 지원
    - XML 리터럴을 지원
    - XPath 탐색을 지원해서 XML 파싱이 쉽다
    - 스칼라3에서는 지원 중단이 예정
- 기타
  - 컴파일 언어미며 REPL을 지원
    - Read-Eval-Print-Loop. 입력받은 것을 읽은 후 평가(실행)해서 그 결과를 출력하는 것을 반복하는 작업.
    - 입력 → 컴파일 → 실행 → 출력의 과정
  - 웹 어플리케이션 개발용 프레임워크로 Play 프레임워크가 있다
  - 